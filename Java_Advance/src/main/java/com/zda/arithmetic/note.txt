常用算法考察
    https://blog.csdn.net/eson_15/column/info/datastructure2
  https://www.cnblogs.com/ysocean/tag/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/
冒泡排序
        /**
         * 1.冒泡排序
         * 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
         * 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
         * 针对所有的元素重复以上的步骤，除了最后一个。
         * 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
         *
         * @param numbers 需要排序的整型数组
         */
快速排序
        /**
         * 2.快速排序算法
         * 通过一趟排序将待排记录分割成独立的两部分,其中一部分记录的关键字均比另一部分的关键字小,
         * 则可以分别对这两部分记录继续进行排序,已达到整个序列有序的目的
         * 本质就是,找一个基位(枢轴,分水岭,作用是左边的都比它小,右边的都比它大.可随机,取名base
         * 首先从序列最右边开始找比base小的,如果小,换位置,从而base移到刚才右边(比较时比base小)的位置(记为临时的high位),这样base右边的都比base大
         * 然后,从序列的最左边开始找比base大的
         * ,如果大,换位置,从而base移动到刚才左边(比较时比base大)的位置(记为临时的low位),这样base左边的都比base小
         * 循环以上两步,直到 low == heigh, 这使才真正的找到了枢轴,分水岭. 返回这个位置,分水岭左边和右边的序列,分别再来递归
         */
插入排序
     每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。

希尔排序
    先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。
    所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；
    然后，取第二个增量d2<d1重复上述的分组和排序，直至所取的增量dt=1(dt<dt-l<…<d2<d1)，即所有记录放在同一组中进行直接插入排序为止。

希尔排序的时间性能优于直接插入排序的原因：
      ①当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。
      ②当n值较小时，n和n2的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度0(n2)差别不大。
      ③在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。
            因此，希尔排序在效率上较直接插人排序有较大的改进。

        增量序列的选择：Shell排序的执行时间依赖于增量序列。好的增量序列的共同特征(查到的资料都这么讲)：
         ① 最后一个增量必须为1；
         ② 应该尽量避免序列中的值(尤其是相邻的值)互为倍数的情况。

归并排序 https://blog.csdn.net/u010853261/article/details/54894057
    归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，归并排序将两个已排序的表合并成一个表。

堆排序https://www.cnblogs.com/CherishFX/p/4643940.html
    是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。

桶排序
    假设输入元素均匀而独立的分布在区间[0，1）上；
     * 桶排序的核心思想是，将[0，1）分为n个大小相同的子区间，
     * 上一个区间里的元素都比下一个区间里的元素小，然后对
     * 所有区间里的元素排序，最后顺序输出所有区间里的元素，
     * 达到对所有元素排序的目的。

动态规划 Dynamic Programming
    基于一个递推公式及一个或多个初始状态。当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度，因此它比回溯法、暴力法等要快许多。
    非常重要的两个概念：状态和状态转移方程。

最长公共子串
    LongestSubstring.java

最长回文子串 PalindromicSubstring.java
        假设一个字符串从左向右写和从右向左写是一样的，这种字符串就叫做palindromic string。如aba,或者abba。

数组的最大k个值(https://www.cnblogs.com/liguangsunls/p/7141686.html)
    问题描写叙述：求一个数组的最大k个数。如，{1,5,8,9,11,2,3}的最大三个数应该是，8,9,11
    问题分析：
         1.解法一：最直观的做法是将数组从大到小排序，然后选出当中最大的K个数。可是这种解法，复杂度是O（logn*n），可是有时候并不须要排序，用简单的选择排序。或者是冒泡排序，那么就K轮的交换或者是选择。就能够得出结论，复杂度是O（n*k），当K非常大的时候排序可能是更好的解法。当K小的时候用选择或者是冒泡效率会更加的高。
    可是这都是会对前K个数进行排序。所以效率不高。当K非常大的时候，以上两种方法效率都不是非常高。
        2.解法二：不正确前K个数进行排序，回顾快排的算法中，那个partition函数。就是随机选择数组中的一个数。把比这个数大的数，放在数组的前面。把比这个数小的数放在数组的
      后面，这时想假设找出的随机数。终于位置就是K，那么最大的K个数就找出来了，沿着这个思路思考问题。可是这个函数。最后的索引位置并不一定是K，可能比K大也可能比K小，我们把找出的数组分成两部分sa。sb，sa是大的部分，sb是小的部分，假设sa的长度等于K的话，那么直接返回就是终于结果，假设sa的长度要比K大的话，那么以sa为新的数组，从sa中找出K个最大的数。这时候就把原始数据集降低到的sa。假设sa的长度比K小的话，增加sa中有m个元素，那么m个元素算作是K中元素的一部分，再从sb中找到，k-m个最大的元素，组合起来就是终于的结果，那么这时把问题简化成从sb中找k-m个最大的元素，所以整体来说这是一个递归的过程，尽管复杂大也是O（n*logn）可是，每一次数据量都会降低所以会更加的快。
       3.解法三：是利用堆排序，建立一个K阶最大堆，然后数据一个个插入队其中，那么插入队的时间复杂度是O（logK），适合数据量比較大的时候，用堆的效果更加好。

数字的最大连续子数组之和
    题目描述：给定一个数组arr，数组中的元素有整数也有负数，数组中的一个或者连续多个数组成一个子数组。
     求所有子数组里面的最大和。例如现在有数组 {1 ， -2 ， 3 ， 10 ， -4 ， 7 ， 2 ， -5 }。
   思路：
    1.用暴力的方法，找出所有可能的子数组，然后找和最大的那个。这是可行的，但是时间复杂度为 n*n，显然是不够理想的。
    2.动态规划思想。状态方程 ： max( dp[ i ] )  = getMax(  max( dp[ i -1 ] ) + arr[ i ] ,arr[ i ] ) 。上面式子的意义是：我们从头开始遍历数组，遍历到数组元素 arr[ i ] 时，连续的最大的和 可能为 max( dp[ i -1 ] ) + arr[ i ] ，也可能为 arr[ i ] ，做比较即可得出哪个更大，取最大值。时间复杂度为 n
    3.不需要动态规划，时间复杂度也为 n 。我们从头开始累加数组的元素，初始值 sum 为 0 。第一步 把 1 累加 则 sum = 1,接着 -2 累加 sum  = -1，再接着 3 累加 sum = 2，但是此时我们发现 sum < 3，也就是说从第一个元素开始累加到第三个元素的 和 sum  比 第三个元素还要小，那么我们舍去前面的累加值，从第三个元素开始累加 ，此时 sum = 3。
     继续上述步骤，直至遍历到数组的最后一个元素。

左旋转字符串
    字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。
     str[i]=str[i+n]

字符串匹配算法:KMP(Knuth-Morris-Pratt)算法 https://blog.csdn.net/sinat_37537673/article/details/73331135
    解决模式串在文本串是否出现过，以及若是出现时，最早出现的位置的经典算法。
二分查找    https://www.cnblogs.com/yedushusheng/p/5524166.html
    二分查找又称折半查找，它是一种效率较高的查找方法。
    二分查找要求：线性表是有序表，即表中结点按关键字有序，并且要用向量作为表的存储结构。不妨设有序表是递增有序的。

链表
    　　链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。
    　　使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

单链表逆序
两个有序单链表合并
两个单链表是否相交
相交处的节点
单链表倒数第K个数
单链表排序
栈和队列
设计包含min函数的栈
    用一个数组，一个top指针指向当前数组最高的，一个size表示数组大小
两个队列实现栈
两个栈实现队列
一个数组实现栈和队列
树
前序、中序、后续遍历
求二叉树的深度
    @Override
    public int getMaxDepth(Node node) {
        if(node==null){
            return 0;
        }else{
            int left=getMaxDepth(node.leftChild);
            int right=getMaxDepth(node.rightChild);
            return  1+Math.max(left,right);
        }
    }
按层次遍历二叉树
   if (node == null) return;
        LinkedList<Node> list = new LinkedList<>();
        list.add(node);
        Node current = node;
        while (!list.isEmpty()) {
            current = list.poll();
            System.out.print(current.data);
            if (current.leftChild != null) list.add(current.leftChild);
            if (current.rightChild != null) list.add(current.rightChild);
        }
判断二叉树是否为完全二叉树
        要么无子节点，要么有左右子节点都不为空
判断二叉树是否镜面对称
判断两颗树是否相等
卡特兰数https://blog.csdn.net/jinhongdu/article/details/8065003
    出栈顺序
    n个节点构成的二叉树个数
    括号化
    凸多边形三角划分
